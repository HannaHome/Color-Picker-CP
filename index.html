<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>色碼選擇器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f7f9fb; }
        #colorCanvas { cursor: crosshair; }
        #valueCanvas { cursor: ns-resize; }
        .picker-indicator {
            position: absolute; width: 12px; height: 12px; border-radius: 50%;
            border: 2px solid white; box-shadow: 0 0 0 1px #000, 0 0 5px rgba(0,0,0,0.8);
            pointer-events: none; transform: translate(-50%, -50%); z-index: 10;
        }
        .slider-indicator {
            position: absolute; width: 100%; height: 8px; background: white;
            border: 2px solid #374151; box-shadow: 0 0 5px rgba(0,0,0,0.4);
            pointer-events: none; transform: translateY(-50%); z-index: 10;
        }
    </style>
</head>
<body class="p-4 md:p-8">

<div class="max-w-4xl mx-auto bg-white p-6 rounded-xl shadow-2xl">
    <h1 class="text-3xl font-bold text-gray-800 mb-6 border-b pb-2">色彩選擇器 (Hex/RGB/HSV)</h1>
    <div class="flex flex-col lg:flex-row gap-6">

        <!-- 左側選擇器 -->
        <div class="lg:w-2/3 flex flex-col gap-6">
            <div class="flex gap-4 h-80">
                <div id="colorPickerContainer" class="relative flex-grow h-full rounded-lg overflow-hidden shadow-md border border-gray-300">
                    <canvas id="colorCanvas" class="w-full h-full"></canvas>
                    <div id="hsIndicator" class="picker-indicator"></div>
                </div>
                <div id="valueSliderContainer" class="relative w-8 h-full rounded-lg overflow-hidden shadow-md border border-gray-300">
                    <canvas id="valueCanvas" class="w-full h-full"></canvas>
                    <div id="vIndicator" class="slider-indicator"></div>
                </div>
            </div>
            <div class="w-full h-32 rounded-lg shadow-inner flex items-center justify-center border border-gray-200" id="previewBox">
                <span class="text-lg font-semibold text-white p-2 rounded-lg bg-black bg-opacity-30">選定顏色預覽</span>
            </div>
        </div>

        <!-- 右側色碼區 -->
        <div class="lg:w-1/3 space-y-4">
            <div class="bg-gray-50 p-4 rounded-xl shadow-inner space-y-3">
                <h2 class="text-xl font-semibold text-gray-700">色碼換算與輸入</h2>

                <!-- HEX 色碼 -->
                <div class="relative">
                    <label for="hexInput" class="block text-sm font-medium text-gray-700 mb-1">16 進位色碼 (HEX)</label>
                    <div class="relative mt-1 rounded-md shadow-sm flex items-center">
                        <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                            <span class="text-gray-500">#</span>
                        </div>
                        <input type="text" id="hexInput" maxlength="6"
                            class="block w-full pl-7 pr-16 py-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 sm:text-sm uppercase tracking-wider"
                            value="FF0000" oninput="handleHexInput(this.value)">
                        <button type="button" id="copyHexBtn"
                            class="absolute right-1 top-1/2 -translate-y-1/2 px-3 py-1 bg-blue-500 text-white rounded-lg text-sm hover:bg-blue-600">
                            複製
                        </button>
                    </div>
                    <span id="copyTip" class="text-sm text-green-600 ml-2 hidden">已複製!</span>
                </div>

                <!-- RGB 色碼 -->
                <div class="flex space-x-2">
                    <div class="flex-1">
                        <label for="rgbR" class="block text-sm font-medium text-red-500 mb-1">R (紅)</label>
                        <input type="number" id="rgbR" min="0" max="255"
                            class="w-full p-2 border border-gray-300 rounded-lg focus:ring-red-500 focus:border-red-500 text-center"
                            value="255" oninput="handleRgbInput()">
                    </div>
                    <div class="flex-1">
                        <label for="rgbG" class="block text-sm font-medium text-green-500 mb-1">G (綠)</label>
                        <input type="number" id="rgbG" min="0" max="255"
                            class="w-full p-2 border border-gray-300 rounded-lg focus:ring-green-500 focus:border-green-500 text-center"
                            value="0" oninput="handleRgbInput()">
                    </div>
                    <div class="flex-1">
                        <label for="rgbB" class="block text-sm font-medium text-blue-500 mb-1">B (藍)</label>
                        <input type="number" id="rgbB" min="0" max="255"
                            class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 text-center"
                            value="0" oninput="handleRgbInput()">
                    </div>
                </div>
            </div>
        </div>

    </div>
</div>

<script>
    // --- 全域狀態 ---
    var H = 0, S = 1, V = 1, R = 255, G = 0, B = 0;
    var isPickingColor = false, isSlidingValue = false;

    const colorCanvas = document.getElementById('colorCanvas');
    const colorCtx = colorCanvas.getContext('2d');
    const valueCanvas = document.getElementById('valueCanvas');
    const valueCtx = valueCanvas.getContext('2d');
    const previewBox = document.getElementById('previewBox');
    const hsIndicator = document.getElementById('hsIndicator');
    const vIndicator = document.getElementById('vIndicator');
    const hexInput = document.getElementById('hexInput');
    const rgbR = document.getElementById('rgbR');
    const rgbG = document.getElementById('rgbG');
    const rgbB = document.getElementById('rgbB');
    const colorContainer = document.getElementById('colorPickerContainer');
    const valueContainer = document.getElementById('valueSliderContainer');
    const copyBtn = document.getElementById('copyHexBtn');
    const copyTip = document.getElementById('copyTip');

    // --- 工具函數 ---
    function hsvToRgb(h, s, v) {
        h /= 60; const i = Math.floor(h), f = h-i;
        const p = v*(1-s), q=v*(1-f*s), t=v*(1-(1-f)*s);
        let r=0,g=0,b=0;
        switch(i%6){ case 0:r=v;g=t;b=p;break; case 1:r=q;g=v;b=p;break; case 2:r=p;g=v;b=t;break; case 3:r=p;g=q;b=v;break; case 4:r=t;g=p;b=v;break; case 5:r=v;g=p;b=q;break;}
        return {r:Math.round(r*255), g:Math.round(g*255), b:Math.round(b*255)};
    }

    function rgbToHsv(r,g,b){
        const r_=r/255,g_=g/255,b_=b/255;
        const max=Math.max(r_,g_,b_),min=Math.min(r_,g_,b_),delta=max-min;
        let h=0,s=0,v=max;
        if(delta!==0){s=delta/max;
            if(max===r_){h=(g_-b_)/delta+(g_<b_?6:0);}
            else if(max===g_){h=(b_-r_)/delta+2;}
            else{h=(r_-g_)/delta+4;}
            h*=60;
        }
        return {h:s===0?0:h,s:v===0?0:s,v:v};
    }

    function rgbToHex(r,g,b){ const toHex=c=>c.toString(16).padStart(2,'0'); return `${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase(); }
    function hexToRgb(hex){
        hex=hex.replace(/^#/,'');
        if(hex.length===3) hex=hex.split('').map(c=>c+c).join('');
        if(hex.length!==6) return {r:0,g:0,b:0};
        return {r:parseInt(hex.substr(0,2),16), g:parseInt(hex.substr(2,2),16), b:parseInt(hex.substr(4,2),16)};
    }

    function drawColorCanvas(){
        const w=colorCanvas.width,h=colorCanvas.height;
        colorCtx.clearRect(0,0,w,h);
        let gradientH=colorCtx.createLinearGradient(0,0,w,0);
        for(let i=0;i<=360;i+=60){ gradientH.addColorStop(i/360,`hsl(${i},100%,50%)`); }
        colorCtx.fillStyle=gradientH; colorCtx.fillRect(0,0,w,h);
        let gradientS=colorCtx.createLinearGradient(0,0,0,h);
        gradientS.addColorStop(0,'rgba(255,255,255,1)');
        gradientS.addColorStop(1,'rgba(255,255,255,0)');
        colorCtx.fillStyle=gradientS; colorCtx.fillRect(0,0,w,h);
        let gradientV=colorCtx.createLinearGradient(0,0,0,h);
        gradientV.addColorStop(0,'rgba(0,0,0,0)'); gradientV.addColorStop(1,'rgba(0,0,0,1)');
        colorCtx.fillStyle=gradientV; colorCtx.fillRect(0,0,w,h);
    }

    function drawValueCanvas(){
        const w=valueCanvas.width,h=valueCanvas.height;
        const pure= hsvToRgb(H,S,1);
        const color=`rgb(${pure.r},${pure.g},${pure.b})`;
        const grad=valueCtx.createLinearGradient(0,0,0,h);
        grad.addColorStop(0,color); grad.addColorStop(1,'#000');
        valueCtx.fillStyle=grad; valueCtx.fillRect(0,0,w,h);
    }

    function updateDisplay(){
        const rgb=hsvToRgb(H,S,V); R=rgb.r;G=rgb.g;B=rgb.b;
        rgbR.value=R; rgbG.value=G; rgbB.value=B;
        const hex=rgbToHex(R,G,B); hexInput.value=hex;
        const colorStr=`#${hex}`;
        previewBox.style.backgroundColor=colorStr;
        const brightness=(R*299+G*587+B*114)/1000;
        const textColor=brightness>128?'text-gray-900':'text-white';
        const textEl=previewBox.querySelector('span');
        textEl.className=`text-lg font-semibold p-2 rounded-lg bg-black bg-opacity-30 ${textColor}`;

        const hsX=H/360*colorCanvas.width, hsY=S*colorCanvas.height;
        hsIndicator.style.left=`${hsX}px`; hsIndicator.style.top=`${hsY}px`;
        const vY=(1-V)*valueCanvas.height; vIndicator.style.top=`${vY}px`;
        vIndicator.style.backgroundColor=colorStr;
        drawValueCanvas();
    }

    function handleColorPick(e){
        if(!isPickingColor && e.type!=='mousedown' && e.type!=='touchstart') return;
        const rect=colorCanvas.getBoundingClientRect();
        let x=e.touches?e.touches[0].clientX:e.clientX;
        let y=e.touches?e.touches[0].clientY:e.clientY;
        x=Math.max(0,Math.min(x-rect.left,rect.width));
        y=Math.max(0,Math.min(y-rect.top,rect.height));
        H=(x/rect.width)*360; S=y/rect.height; S=Math.max(0,Math.min(S,1));
        updateDisplay(); if(e.cancelable) e.preventDefault();
    }

    function handleValueSlide(e){
        if(!isSlidingValue && e.type!=='mousedown' && e.type!=='touchstart') return;
        const rect=valueCanvas.getBoundingClientRect();
        let y=e.touches?e.touches[0].clientY:e.clientY;
        y=Math.max(0,Math.min(y-rect.top,rect.height));
        V=1-(y/rect.height); V=Math.max(0,Math.min(V,1));
        updateDisplay(); if(e.cancelable) e.preventDefault();
    }

    function handleHexInput(hex){
        if(hex.length===6||hex.length===3){
            const rgb=hexToRgb(hex);
            if(!isNaN(rgb.r)){R=rgb.r;G=rgb.g;B=rgb.b;}
            const hsv=rgbToHsv(R,G,B); H=hsv.h; S=hsv.s; V=hsv.v;
            drawValueCanvas(); updateDisplay();
        }
    }

    function handleRgbInput(){
        R=Math.max(0,Math.min(parseInt(rgbR.value||0),255));
        G=Math.max(0,Math.min(parseInt(rgbG.value||0),255));
        B=Math.max(0,Math.min(parseInt(rgbB.value||0),255));
        const hsv=rgbToHsv(R,G,B); H=hsv.h; S=hsv.s; V=hsv.v;
        drawValueCanvas(); updateDisplay();
    }

    // 複製 HEX 功能
    copyBtn.addEventListener('click',()=>{
        navigator.clipboard.writeText(`#${hexInput.value}`).then(()=>{
            copyTip.classList.remove('hidden');
            setTimeout(()=>copyTip.classList.add('hidden'),1000);
        }).catch(err=>console.error('複製失敗:',err));
    });

    function init(){
        const colorRect=colorContainer.getBoundingClientRect();
        colorCanvas.width=colorRect.width; colorCanvas.height=colorRect.height;
        const valueRect=valueContainer.getBoundingClientRect();
        valueCanvas.width=valueRect.width; valueCanvas.height=valueRect.height;

        drawColorCanvas(); updateDisplay();

        // H/S 選擇
        colorCanvas.addEventListener('mousedown', e=>{isPickingColor=true;handleColorPick(e);});
        document.addEventListener('mousemove', e=>{if(isPickingColor) handleColorPick(e);});
        document.addEventListener('mouseup', ()=>{isPickingColor=false;});
        colorCanvas.addEventListener('touchstart', e=>{isPickingColor=true;handleColorPick(e);});
        document.addEventListener('touchmove', e=>{if(isPickingColor) handleColorPick(e);});
        document.addEventListener('touchend', ()=>{isPickingColor=false;});
        document.addEventListener('touchcancel', ()=>{isPickingColor=false;});

        // V 滑桿
        valueCanvas.addEventListener('mousedown', e=>{isSlidingValue=true;handleValueSlide(e);});
        document.addEventListener('mousemove', e=>{if(isSlidingValue) handleValueSlide(e);});
        document.addEventListener('mouseup', ()=>{isSlidingValue=false;});
        valueCanvas.addEventListener('touchstart', e=>{isSlidingValue=true;handleValueSlide(e);});
        document.addEventListener('touchmove', e=>{if(isSlidingValue) handleValueSlide(e);});
        document.addEventListener('touchend', ()=>{isSlidingValue=false;});
        document.addEventListener('touchcancel', ()=>{isSlidingValue=false;});

        window.addEventListener('resize',()=>{
            const colorRect=colorContainer.getBoundingClientRect();
            colorCanvas.width=colorRect.width; colorCanvas.height=colorRect.height;
            const valueRect=valueContainer.getBoundingClientRect();
            valueCanvas.width=valueRect.width; valueCanvas.height=valueRect.height;
            drawColorCanvas(); updateDisplay();
        });
    }

    window.onload=init;
</script>

</body>
</html>
